---
title: "Seurat_Part1_prenorm"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

First initialize biocManager and Seurat, and walk into your directory. If you have not yet installed Seurat and ggplot2, you will need to un-hash out the biocManager commands below. 

```{r}
#install.packages("BiocManager")

#BiocManager::install("Seurat")
#BiocManager::install("ggplot2")
#BiocManager::install("sctransform")

library(Seurat)
library(ggplot2)
library(sctransform)
dir= "/Users/whippoorwill/Dropbox (Anna Molofsky Lab)/2020-Leah-barrelCortex/Manuscript data/Sequencing/LD_AVM02/Data/"
 #set this to whatever you like, above the level of your data folder
setwd(dir)
```

Tell yourself where the files are 

```{r}
dataset_loc<-file.path(dir,"Data")
```

Then create an object with the folder names that you can use to open each sample folder when you need it
```{r}
sample1<-"LD5RC"
sample2<-"LD5LD"
sample3<-"LD7RC"
sample4<-"LD7LD"
ids <-c(sample1,sample2,sample3,sample4)
```

For each ID (i.e. folder), read in the data (stored in mm10) and change the colnames as follows:

split the colnames that already exist into a list; then remove anything after "-" (split), then extract only the first element ('[[', index = 1L), then paste the ID to each colname (gene) separated by "-". Return d10x. Repeat for each id. 

```{r}
d10x.data <- sapply(ids, function(i){
        d10x <- Read10X(file.path(dataset_loc, i,"filtered_feature_bc_matrix")) #read in the file for id[i]
        colnames(d10x) <- paste(sapply(strsplit(colnames(d10x),split="-"),'[[',1L),i,sep="-") 
        d10x
})
```

The d10x.data list object contains a set of lists whose columns consist of cell IDs and whose rows represent genes. 
Make experiment.data into an array with each element of d10x.data (which is a list) as columns (as many columns as cells per sample)
This creates a new array that contains all of the cells and genes from d10x.data but puts them in one list instead of 3. 

```{r}
experiment.data<-do.call("cbind",d10x.data)
```

"aggregate" the data which cellRanger does but not well. Create a seurat object, keeping genes that are in >3 cells, cells with >50 genes (you can always set these to zero and filter later)

```{r}
project<-"LD_AVM02" #Name this anything you want
MG_all <- CreateSeuratObject(
        experiment.data,
        project = project, 
        min.cells = 1,
        min.features = 1,
        names.field = 2,
        names.delim = "\\-")
```

Calculate mitochondrial content, add as metadata to each cell (column). Percent mito is literally dividing one matrix by another matrix to get a percentage. Grep searches through rownames of the data (i.e. genes) for anything that starts with mt. 

```{r}
MG_all <- PercentageFeatureSet(MG_all, pattern = "^mt-", col.name = "percent.mito")
```


Extract the sampleIDs which are stored in "orig.ident". The numbers are numbers of cells (columns). Orig.ident is defined by the file from which the data was isolated. 

```{r}
samplename = MG_all$orig.ident
table(samplename)
```

add sample descriptions to the column (cell) names for each sample. if you call a name of a cell you can see which sample it's from

```{r}
description1<-"Control_P5"
description2<-"Deprived_P5"
description3<-"Control_P7"
description4<-"Deprived_P7"
sample_description = rep(description1,length(samplename)) #repeat description for each cell in all samples
sample_description[samplename %in% sample2] = description2 #every index for a sample2 cell gets this name
sample_description[samplename %in% sample3] = description3 
sample_description[samplename %in% sample4] = description4 

names(sample_description) = rownames(MG_all@meta.data) #the rownames of meta.data are the cellIDs. Now you have named each ordered sample description with its own cellIDs (this works because we pulled both samplename and the rownames from the same meta.data matrix and never re-ordered it)
table(sample_description)
```

add the names into your metadata for each cell
```{r}
MG_all$sample_description<-sample_description
```

different ways to view the aggregated data

```{r}
table(MG_all$sample_description,MG_all$orig.ident)
```

```{r}
slotNames(MG_all)
```

find out whether they are full or empty
```{r}
str(MG_all,max.level = 2)
```

```{r}
head(MG_all@meta.data)
```

QC - decide on final filtering parameters, look for clear outliers/differences between samples. These are quantiles of cells. Also shows you the variability between cells (and between samples)
5% quantiles for number of genes per cell per sample - nGene is in the metadata for each cell, run quantiles on each sample from 0-1 in increments of 0.05

i.e. 50th percentile of cells have about 2000 genes per cell per sample for sorted cells
        -did the unsorted samples run correctly? these are very low gene counts and extremely low UMI/gene ratios. Also they have high percentages of mitochondrial genes. 

Show 5% quantiles for number of UMI per cell per sample
```{r}
do.call("cbind", tapply(MG_all$nCount_RNA,MG_all$sample_description,quantile,probs=seq(0,1,0.05)))
do.call("cbind", tapply(MG_all$nFeature_RNA,MG_all$sample_description,quantile,probs=seq(0,1,0.05)))
round(do.call("cbind", tapply(MG_all$percent.mito,MG_all$sample_description,quantile,probs=seq(0,1,0.05))), digits = 3)
```
Show 5% quantiles for mitochondrial genes. Note the large gap between 95%, 100% - maybe filter the top 5% of mt high-expressing cells. But you need to think about what those cells are really doing. Are they dead? Highly active/reactive? 
```{r}
mlo = -Inf
mhi = 10
clo = 1000
chi = 35000
flo = 500
fhi = 7500
```


Plot the number of cells each gene is represented by - i.e. how many cells express any given gene? Ordered from rare to common genes. So you might consider focusing on genes that are relatively well expressed across the sample, or you might care about genes expressed only in a small subset of cells. The >=2 refers to read number per cell. 
```{r}
plot(sort(Matrix::rowSums(GetAssayData(MG_all)>=2)),xlab="gene rank",ylab="number of cells",main="Cells per genes ( >= 2 )")
#median(rowSums(GetAssayData(LD1)>=2))
```
Violin plot of 1) number of genes, 2) number of UMI and 3) percent mitochondrial genes
```{r}
VlnPlot(
  MG_all,
  c("nFeature_RNA"),
  pt.size = 0) + geom_abline(intercept = fhi, slope = 0, linetype = "dashed",color = "red", size = .8) + geom_abline(intercept = flo, slope = 0, linetype = "dashed",color = "black", size = .8)
VlnPlot(
  MG_all,
  c("nCount_RNA"),
  pt.size = 0) + geom_abline(intercept = chi, slope = 0, linetype = "dashed",color = "red", size = .8) + geom_abline(intercept = clo, slope = 0, linetype = "dashed",color = "black", size = .8)
VlnPlot(
  MG_all,
  c("percent.mito"),
  pt.size = 0)+ geom_abline(intercept = mhi, slope = 0, linetype = "dashed",color = "red", size = .8) + geom_abline(intercept = mlo, slope = 0, linetype = "dashed",color = "black", size = .8)
```

Gene Plot, scatter plot of gene expression across cells, (colored by sample) - sequencing depth relative to genes; looking for similarity across samples. Some cell types can have relatively few genes, but highly expressed, could show up as a second arc below the one seen here (should contain all samples though)
```{r}
FeatureScatter(
  MG_all, "nCount_RNA", "nFeature_RNA")

FeatureScatter(
  MG_all, "nCount_RNA", "percent.mito")

FeatureScatter(object=MG_all,"nFeature_RNA","percent.mito")

```




Filtering cells: note that they are taking these filters and duplicating them across all samples. Use -Inf instead of 0 because not all the filters have to be positive values, and to avoid any errors due to truncation. 

How to select filters??? noise vs signal - get them from the violin plots and the matrix, capture the bulk of cells but exclude outliers (say with mtDNA filter) - can also look at percentiles, maybe get rid of top 5% since it was very different from the rest. Basically eliminate outliers and don't include cells that have hardly any genes or have a ton of genes expressed

If I later decide to QC separately: 
```{r}
MG_all = subset(MG_all, subset = percent.mito>mlo & percent.mito < mhi)
MG_all = subset(MG_all, subset = nCount_RNA>clo & nCount_RNA < chi)
MG_all = subset(MG_all, subset = nFeature_RNA>flo & nFeature_RNA < chi)
MG <- NormalizeData(MG_all,normalization.method = "LogNormalize", scale.factor = 10000)
VlnPlot(MG,c("Cx3cr1","Hmbs","Aif1","Actb"))
GetAssayData(MG)[1:10, 1:15]
table(MG$sample_description)
```



#Assign cell names of "Male" or "Female" depending on Xist expression
```{r}
#Replace all instances of "MG" with the name of your seurat object
#identify cell names with Xist expression
female<-WhichCells(object = MG, expression = Xist > 0,slot = "counts") 

#identify cell names without Xist expression
male<-WhichCells(object = MG, expression = Xist == 0, slot = "counts") 

#set up a vector with the correct number of "male" and "female" labels
sex=as.factor(c(rep("Female",length(female)),rep("Male",length(male)))) 

#assign each cell ID to its appropriate label; must match order set up in the vector above.
names(sex)<-c(female,male) 
table(sex)

#order this vector by the cellnames vector found in names(DG@meta.data)
cellnames = rownames(MG@meta.data)
sex = sex[match(cellnames,names(sex))] 

#Add in a metadata column for the sex of the cell/animal
MG$sex <- sex

#Check that the numbers match with the table above
table(MG$sex) 
table(MG$sex,MG$sample_description)

#Create a new metadata column combining sample_description [or in your case Il33 geneotype, whatever that is named in your metadata] and sex: 
fulldescription = paste0(MG$sample_description, "_",MG$sex)
names(fulldescription) = names(MG@meta.data)
table(fulldescription)
MG$fulldescription = fulldescription

#violin plot of any gene (geneofinterest) grouped by Il33 status (orig.ident) and split by sex
geneofinterest = ""
VlnPlot(MG,c("Xist",geneofinterest),group.by = "orig.ident",split.by = "sex")

#Umap plot, showing a separate plot for each sex (change celltype to your region-specific metadata column name): 
DimPlot(MG,group.by = "celltype",split.by = "sex")

```


Normalize the data - counts per 10k (per million makes no sense) - set by the "scale.factor". Raw data has the original data; the data slot has the filtered data (from above); the normalization will work on the raw data but only pulls the cells that are included in your filtered "data" and store the normalization as data (NOT the scale data slot) - so it isn't working on the filtered data, it's working on the raw data. The only filter they take into account is for cells - you can't filter out genes before normalization. 



Filtering out genes in Seurat - use AFTER normalization. Works on data object (i.e. normalized, filtered data). Currently set to eliminate genes expressed in fewer than 100 cells. 
Option A: standard

```{r}
MG<-FindVariableFeatures(MG, selection.method = "vst", nfeatures = 6000)
top10 <- head(VariableFeatures(MG),10)
plot1 <- VariableFeaturePlot(MG)
plot2 <- LabelPoints(plot=plot1, points = top10, repel = T, xnudge = 0, ynudge = 0)
plot2

VlnPlot(MG,c("Hmbs","Hbb-bs"))
```

Scale the data
```{r}
all.genes<-rownames(MG)
var.genes = VariableFeatures(MG)
MG<-ScaleData(MG,features = var.genes, vars.to.regress = c("percent.mito","nCount_RNA"))
```

Option B: Sctransform
```{r}
#LD1 <- SCTransform(LD1, vars.to.regress = "percent.mito", verbose = FALSE,variable.features.n = #3000,conserve.memory = T,return.only.var.genes = T)
```

Dimensionality reduction. Note that UMAP can be run directly on most variable features as well. 
```{r}
MG <- RunPCA(MG,features = var.genes,npcs = 50, verbose = FALSE)
set.seed(1)
MG<-RunUMAP(MG,reduction = "pca",dims = 1:30, verbose = F)
MG<-FindNeighbors(MG,dims=1:30,verbose=F)
set.seed(1)
MG<-FindClusters(MG,verbose=F,resolution = 0.5)
```

```{r}
DimPlot(MG,label=T,reduction = "umap")
FeaturePlot(MG,c("Cx3cr1","Aldh1l1","Pdgfra","Rbfox3"),reduction = "umap")
FeaturePlot(MG,c("Mbp","P2ry12","Pecam1","Itgam","Gad1"),reduction = "umap")
DimPlot(MG,reduction = "umap",group.by = "fulldescription")
FeaturePlot(MG,features = "percent.mito")
FeaturePlot(MG,features = "nCount_RNA")
FeaturePlot(MG,features = "nFeature_RNA")
FeaturePlot(MG,features = "Ptprc")
FeaturePlot(MG,features = "Cd14")
```
```{r}
DimPlot(MG,reduction = "umap",group.by = "fulldescription")
DimPlot(MG,reduction = "umap",group.by = "sex")
DimPlot(MG,reduction = "umap",group.by = "sample_description")
age = MG$sample_description
age[age %in% c("Control_P5","Deprived_P5")]="P5"
age[age%in% c("Control_P7","Deprived_P7")] = "P7"
MG$age = age
DimPlot(MG,reduction = "umap",group.by = "sample_description",split.by = "age")
DimPlot(MG,reduction = "umap",group.by = "seurat_clusters",split.by = "sample_description",label = T)
```


```{r}
table(MG$sample_description,MG$seurat_clusters)
table(MG$fulldescription,MG$seurat_clusters)
table(MG$sex,MG$seurat_clusters)
table(MG$age,MG$seurat_clusters)
```

Edit this section everytime! The cluster numbers will vary
```{r}
microglia = c(0,2,3,4,5,6,7,8,10,12)
monocytes = 15
astrocytes = 11
OPC_other = 9
endothelial = 14
#pericytes = 14
oligos = 13
neurons = 1
#other = c(14)
types = 0:15
types[microglia+1]="microglia"
types[monocytes+1]="monocytes"
types[astrocytes+1]="astro"
types[oligos+1]="oligo"
types[neurons+1]="neurons"
types[endothelial+1]="endothelial"
types[OPC_other+1]="OPC_other"
celltype = MG$seurat_clusters
levels(celltype) = types
MG$celltype = celltype
table(MG$celltype,MG$seurat_clusters)
celltypecluster = paste0(MG$celltype,"_",MG$seurat_clusters)
MG$celltypecluster = celltypecluster
```
```{r}
table(MG$celltype,MG$sample_description)
r = table(MG$celltypecluster,MG$sample_description)
t = r*100/colSums(r) #percent of cells in that sample that happen to fall into a specific cluster
r
t
```
Summary: Astro_11 - more from Dep P5 than others
endothelial - consistent
micro_0 - more from control P7
micro_10 - all dep P5
micro_12 - more P7
micro_2 - more P7
micro_3 - more P5, more ctrl, lowest P7 dep
micro_4 - consistent
micro_5 - mostly P7 ctrl
micro_6 - consistent
micro_7 - P7 ctrl
micro_8 - consistent
monocytes - more P7
neurons - less in P7 ctrl
oligo - consistent
OPC/other - consistent

```{r}
Idents(MG)="celltype"
VlnPlot(MG,c("Rbfox3","Aif1","Itgam","Cx3cr1","Aldh1l1","Xist"),group.by = "celltype",pt.size = .2)
VlnPlot(MG,c("Cx3cr1","P2ry12","Il13ra1","Il4ra"),group.by = "celltypecluster",idents = "microglia",ncol = 2,pt.size = .2)
VlnPlot(MG,c("Cx3cr1","P2ry12","Il13ra1","Il4ra"),group.by = "sample_description",idents = "microglia",ncol = 2,pt.size = .2)
VlnPlot(MG,c("Ctsa","Ctsb","Ctsc","Ctsf"),group.by = "sample_description",idents = "microglia",ncol = 2,pt.size = .2)

```
```{r}
r = table(MG$celltypecluster,MG$sample_description)
ratiotable = r/colSums(r)
max = max.col(ratiotable)
#ratiotable = as.data.frame(cbind(ratiotable,max))
r = apply(X = ratiotable,MARGIN = 1,FUN = function(x)max(x)/min(x))
r
```

Save the filtered, normalized data
```{r}
filename="MG_umap.RData"
save(MG,file=filename)
```
*************** END HERE ********************
